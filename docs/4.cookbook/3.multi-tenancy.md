---
title: Multi-Tenancy
description: Isolating data with namespaces
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Cookbook
  - Multi-Tenancy
  - Namespaces
---

# Multi-Tenancy

This cookbook covers patterns for multi-tenant vector applications using namespaces.

## Overview

Multi-tenancy isolates data between customers/organizations. Vector databases support this through:

| Provider | Isolation Method |
|----------|------------------|
| Pinecone | Namespaces |
| Qdrant | Collections or payload filtering |
| Milvus | Partitions |
| Weaviate | Tenants |

## Basic Namespace Usage

### Search in Tenant Namespace

```go
func SearchForTenant(v *vectql.VECTQL, tenantID string) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(10).
        Namespace(v.P("tenant_id")).
        Render(pinecone.New())
}
```

### Upsert to Tenant Namespace

```go
func UpsertForTenant(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    record := vectql.NewRecord(v.P("id"), vectql.Vec(v.P("embedding"))).
        WithMetadata(v.M("documents", "title"), v.P("title")).
        Build()

    return vectql.Upsert(v.C("documents")).
        AddVector(record).
        Namespace(v.P("tenant_id")).
        Render(pinecone.New())
}
```

### Delete from Tenant Namespace

```go
func DeleteForTenant(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Delete(v.C("documents")).
        IDs(v.P("ids")).
        Namespace(v.P("tenant_id")).
        Render(pinecone.New())
}
```

## Tenant Service Pattern

```go
type TenantVectorService struct {
    instance *vectql.VECTQL
    renderer vectql.Renderer
}

func NewTenantVectorService(schema *vdml.Schema, renderer vectql.Renderer) (*TenantVectorService, error) {
    instance, err := vectql.NewFromVDML(schema)
    if err != nil {
        return nil, err
    }
    return &TenantVectorService{
        instance: instance,
        renderer: renderer,
    }, nil
}

func (s *TenantVectorService) Search(tenantID string, queryVec []float32, topK int) (*vectql.QueryResult, error) {
    return vectql.Search(s.instance.C("documents")).
        Vector(vectql.Vec(s.instance.P("query_vec"))).
        Embedding(s.instance.E("documents", "embedding")).
        TopK(topK).
        Namespace(s.instance.P("tenant_id")).
        Render(s.renderer)
}

func (s *TenantVectorService) Upsert(tenantID string, records []DocumentRecord) (*vectql.QueryResult, error) {
    builder := vectql.Upsert(s.instance.C("documents")).
        Namespace(s.instance.P("tenant_id"))

    for i, r := range records {
        record := vectql.NewRecord(
            s.instance.P(fmt.Sprintf("id_%d", i)),
            vectql.Vec(s.instance.P(fmt.Sprintf("vec_%d", i))),
        ).
            WithMetadata(s.instance.M("documents", "title"), s.instance.P(fmt.Sprintf("title_%d", i))).
            Build()
        builder = builder.AddVector(record)
    }

    return builder.Render(s.renderer)
}

func (s *TenantVectorService) Delete(tenantID string, ids []string) (*vectql.QueryResult, error) {
    return vectql.Delete(s.instance.C("documents")).
        IDs(s.instance.P("ids")).
        Namespace(s.instance.P("tenant_id")).
        Render(s.renderer)
}

func (s *TenantVectorService) ClearTenant(tenantID string) (*vectql.QueryResult, error) {
    return vectql.Delete(s.instance.C("documents")).
        DeleteAll(true).
        Namespace(s.instance.P("tenant_id")).
        Render(s.renderer)
}
```

## Metadata-Based Tenancy

Alternative approach using metadata filtering:

```go
func SearchWithTenantFilter(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(10).
        Filter(v.Eq(v.M("documents", "tenant_id"), v.P("tenant_id"))).
        Render(pinecone.New())
}
```

### Comparison

| Approach | Pros | Cons |
|----------|------|------|
| Namespaces | Strong isolation, efficient | Limited cross-tenant queries |
| Metadata filtering | Flexible, cross-tenant possible | Less efficient for large datasets |

## Hierarchical Tenancy

For organization → team → user hierarchy:

```go
// Organization-level search
func SearchOrg(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(10).
        Namespace(v.P("org_id")).
        Render(pinecone.New())
}

// Team-level search within org
func SearchTeam(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(10).
        Namespace(v.P("org_id")).
        Filter(v.Eq(v.M("documents", "team_id"), v.P("team_id"))).
        Render(pinecone.New())
}

// User-level search within team
func SearchUser(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(10).
        Namespace(v.P("org_id")).
        Filter(v.And(
            v.Eq(v.M("documents", "team_id"), v.P("team_id")),
            v.Eq(v.M("documents", "user_id"), v.P("user_id")),
        )).
        Render(pinecone.New())
}
```

## Tenant Onboarding

```go
func OnboardTenant(v *vectql.VECTQL, tenantID string, initialDocs []Document) error {
    // Namespace is created automatically on first upsert
    builder := vectql.Upsert(v.C("documents")).
        Namespace(v.P("tenant_id"))

    for i, doc := range initialDocs {
        record := vectql.NewRecord(
            v.P(fmt.Sprintf("id_%d", i)),
            vectql.Vec(v.P(fmt.Sprintf("vec_%d", i))),
        ).
            WithMetadata(v.M("documents", "title"), v.P(fmt.Sprintf("title_%d", i))).
            Build()
        builder = builder.AddVector(record)
    }

    _, err := builder.Render(pinecone.New())
    return err
}
```

## Tenant Offboarding

```go
func OffboardTenant(v *vectql.VECTQL, tenantID string) error {
    // Delete all vectors in tenant namespace
    _, err := vectql.Delete(v.C("documents")).
        DeleteAll(true).
        Namespace(v.P("tenant_id")).
        Render(pinecone.New())
    return err
}
```

## Cross-Tenant Operations (Admin)

```go
// Admin search across all tenants (use sparingly)
func AdminSearch(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    // Search without namespace filter
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("documents", "embedding")).
        TopK(100).
        Render(pinecone.New())
}
```

## Best Practices

1. **Use namespaces for strong isolation** - Prevents accidental data leakage
2. **Validate tenant access** - Always verify tenant ownership before operations
3. **Separate admin operations** - Use different code paths for admin vs tenant
4. **Plan for scale** - Consider namespace limits per provider
5. **Audit cross-tenant access** - Log any operations that span tenants
6. **Include tenant_id in metadata** - Backup isolation layer

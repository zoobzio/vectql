---
title: Similarity Search
description: Semantic search patterns
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Cookbook
  - Similarity Search
  - Semantic Search
---

# Similarity Search

This cookbook covers common semantic search patterns.

## Basic Semantic Search

```go
func SearchProducts(v *vectql.VECTQL, queryVec []float32, k int) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(k).
        Render(pinecone.New())
}
```

## Search with Metadata Filters

### Category Filter

```go
func SearchByCategory(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(10).
        Filter(v.Eq(v.M("products", "category"), v.P("category"))).
        Render(pinecone.New())
}
```

### Price Range Filter

```go
func SearchByPriceRange(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    minPrice := v.P("min_price")
    maxPrice := v.P("max_price")

    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(10).
        Filter(vectql.Range(v.M("products", "price"), &minPrice, &maxPrice)).
        Render(pinecone.New())
}
```

### Combined Filters

```go
func SearchWithFilters(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    minPrice := v.P("min_price")

    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(20).
        Filter(v.And(
            v.Eq(v.M("products", "active"), v.P("active")),
            v.Eq(v.M("products", "category"), v.P("category")),
            vectql.Range(v.M("products", "price"), &minPrice, nil),
        )).
        IncludeMetadata(true).
        Render(pinecone.New())
}
```

## RAG Document Retrieval

```go
func RetrieveDocuments(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("question_embedding"))).
        Embedding(v.E("documents", "content_embedding")).
        TopK(5).
        IncludeMetadata(true).
        Render(pinecone.New())
}

func RetrieveFromSource(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("documents")).
        Vector(vectql.Vec(v.P("question_embedding"))).
        Embedding(v.E("documents", "content_embedding")).
        TopK(5).
        Filter(v.Eq(v.M("documents", "source"), v.P("source"))).
        IncludeMetadata(true).
        Render(pinecone.New())
}
```

## Image Similarity Search

```go
func FindSimilarImages(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("images")).
        Vector(vectql.Vec(v.P("image_embedding"))).
        Embedding(v.E("images", "clip_embedding")).
        TopK(20).
        IncludeMetadata(true).
        Render(pinecone.New())
}
```

## Recommendation System

```go
func GetRecommendations(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    // Use user's preference vector for recommendations
    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("user_preference_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(10).
        Filter(v.And(
            v.Eq(v.M("products", "active"), v.P("active")),
            v.NotIn(v.M("products", "id"), v.P("viewed_ids")), // Exclude viewed items
        )).
        IncludeMetadata(true).
        Render(pinecone.New())
}
```

## Multi-Modal Search

```go
// Search products using both text and image embeddings
func MultiModalSearch(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    // Option 1: Search by text embedding
    textResults, err := vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("text_embedding"))).
        Embedding(v.E("products", "text_embedding")).
        TopK(20).
        Render(pinecone.New())

    // Option 2: Search by image embedding
    imageResults, err := vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("image_embedding"))).
        Embedding(v.E("products", "image_embedding")).
        TopK(20).
        Render(pinecone.New())

    // Combine results at application level
    return textResults, err
}
```

## Namespace-Based Search

```go
func SearchInNamespace(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(10).
        Namespace(v.P("tenant_id")). // Multi-tenant isolation
        Render(pinecone.New())
}
```

## Threshold-Based Search

```go
// Filter results by minimum similarity score
func SearchWithThreshold(v *vectql.VECTQL) (*vectql.QueryResult, error) {
    return vectql.Search(v.C("products")).
        Vector(vectql.Vec(v.P("query_vec"))).
        Embedding(v.E("products", "embedding")).
        TopK(100). // Fetch more, filter by score
        MinScore(v.P("min_score")). // Provider-specific
        Render(pinecone.New())
}
```

## Search Service Pattern

```go
type SearchService struct {
    instance *vectql.VECTQL
    renderer vectql.Renderer
}

type SearchOptions struct {
    QueryVector []float32
    Categories  []string
    MinPrice    *float64
    MaxPrice    *float64
    InStock     *bool
    TopK        int
    Namespace   string
}

func (s *SearchService) Search(opts SearchOptions) (*vectql.QueryResult, error) {
    query := vectql.Search(s.instance.C("products")).
        Vector(vectql.Vec(s.instance.P("query_vec"))).
        Embedding(s.instance.E("products", "embedding")).
        TopK(opts.TopK).
        IncludeMetadata(true)

    // Build filters
    var filters []vectql.FilterItem

    if len(opts.Categories) > 0 {
        filters = append(filters,
            s.instance.In(s.instance.M("products", "category"), s.instance.P("categories")))
    }

    if opts.MinPrice != nil || opts.MaxPrice != nil {
        var min, max *vectql.Param
        if opts.MinPrice != nil {
            p := s.instance.P("min_price")
            min = &p
        }
        if opts.MaxPrice != nil {
            p := s.instance.P("max_price")
            max = &p
        }
        filters = append(filters, vectql.Range(s.instance.M("products", "price"), min, max))
    }

    if opts.InStock != nil {
        filters = append(filters,
            s.instance.Eq(s.instance.M("products", "in_stock"), s.instance.P("in_stock")))
    }

    if len(filters) > 0 {
        query = query.Filter(s.instance.And(filters...))
    }

    if opts.Namespace != "" {
        query = query.Namespace(s.instance.P("namespace"))
    }

    return query.Render(s.renderer)
}
```

## Best Practices

1. **Use appropriate TopK** - Start with 10-20, increase as needed
2. **Include metadata selectively** - Only request what you need
3. **Filter early** - Metadata filters reduce search space
4. **Use namespaces** - Isolate data by tenant or category
5. **Cache embeddings** - Don't recompute query vectors unnecessarily

---
title: Architecture
description: Internal structure and design decisions
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Architecture
  - Design
  - Internals
---

# Architecture

VECTQL follows a layered architecture designed for security, extensibility, and maintainability.

## Layer Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Public API Layer                          │
│  vectql.Search(), vectql.Upsert(), instance.C(), instance.E()   │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Builder Layer                             │
│  Builder struct, method chaining, AST construction               │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Internal Types Layer                         │
│  VectorAST, Collection, EmbeddingField, MetadataField, Param    │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Renderer Layer                             │
│  Pinecone, Qdrant, Milvus, Weaviate providers                   │
└─────────────────────────────────────────────────────────────────┘
```

## Internal Types

Core types live in `internal/types` and cannot be imported by external packages:

```
internal/types/
├── ast.go          # VectorAST + validation
├── collection.go   # Collection reference
├── embedding.go    # EmbeddingField reference
├── metadata.go     # MetadataField reference
├── param.go        # Parameter references
├── filter.go       # FilterItem, FilterCondition, FilterGroup
├── operator.go     # Filter operators
├── vector.go       # VectorValue, SparseVectorValue
├── record.go       # VectorRecord for upserts
└── result.go       # QueryResult type
```

### Why Internal?

Making types internal prevents external code from constructing them directly:

```go
// External package CANNOT do this:
coll := types.Collection{Name: "malicious'; DROP"}  // Bypasses validation!

// External packages MUST use validated accessors:
coll := instance.C("products")  // Validated against schema
```

This is a key security property.

## Instance Layer

The `VECTQL` instance provides validated access to internal types:

```go
type VECTQL struct {
    schema      *vdml.Schema
    collections map[string]*vdml.Collection
    embeddings  map[string]map[string]*vdml.Embedding
    metadata    map[string]map[string]*vdml.MetadataField
}
```

### Validation Methods

Each accessor validates against the schema:

```go
func (v *VECTQL) C(name string) types.Collection {
    c, err := v.TryC(name)
    if err != nil {
        panic(err)
    }
    return c
}

func (v *VECTQL) TryC(name string) (types.Collection, error) {
    if !isValidIdentifier(name) {
        return types.Collection{}, fmt.Errorf("invalid collection name: %s", name)
    }
    if _, exists := v.collections[name]; !exists {
        return types.Collection{}, fmt.Errorf("collection %q not found in schema", name)
    }
    return types.Collection{Name: name}, nil
}
```

## Builder Layer

The `Builder` struct accumulates query components:

```go
type Builder struct {
    ast *types.VectorAST
    err error
}
```

### Method Chaining

Each method returns `*Builder` for chaining:

```go
func (b *Builder) TopK(k int) *Builder {
    if b.err != nil {
        return b
    }
    b.ast.TopK = &types.PaginationValue{Static: &k}
    return b
}

func (b *Builder) Filter(f types.FilterItem) *Builder {
    if b.err != nil {
        return b
    }
    b.ast.Filter = f
    return b
}
```

## Renderer Layer

Providers implement the `Renderer` interface:

```go
type Renderer interface {
    Render(ast *types.VectorAST) (*types.QueryResult, error)
    SupportsOperation(op types.Operation) bool
    SupportsFilter(op types.FilterOperator) bool
}
```

### Provider Capabilities

| Feature | Pinecone | Qdrant | Milvus | Weaviate |
|---------|----------|--------|--------|----------|
| Search | Yes | Yes | Yes | Yes |
| Hybrid search | Yes | Yes | Yes | Yes |
| Metadata filters | Yes | Yes | Yes | Yes |
| Namespaces | Yes | Yes | Yes | Yes |
| Batch upsert | Yes | Yes | Yes | Yes |

## AST Structure

The `VectorAST` captures the complete query specification:

```go
type VectorAST struct {
    Operation     Operation
    Target        Collection
    Embedding     *EmbeddingField
    Vector        *VectorValue
    SparseVector  *SparseVectorValue
    Filter        FilterItem
    TopK          *PaginationValue
    IncludeMeta   bool
    IncludeVector bool
    Namespace     *Param
    Records       []VectorRecord    // For Upsert
    IDs           *Param            // For Delete/Fetch
    Updates       map[MetadataField]Param  // For Update
}
```

## Package Structure

```
vectql/
├── api.go           # Public type re-exports (safe types only)
├── builder.go       # Query builder
├── expressions.go   # Filter/vector helper functions
├── instance.go      # VDML integration, validation
├── renderer.go      # Renderer interface
├── internal/types/  # Internal type definitions
└── pkg/
    ├── pinecone/    # Pinecone renderer
    ├── qdrant/      # Qdrant renderer
    ├── milvus/      # Milvus renderer
    └── weaviate/    # Weaviate renderer
```

## Design Principles

### 1. Defense in Depth

Multiple layers of validation ensure security even if one layer fails.

### 2. Fail Fast

Invalid inputs cause immediate panics (or errors with `Try` variants).

### 3. Type Safety

Go's type system enforces correct usage at compile time where possible.

### 4. Provider Abstraction

The same builder API works across all providers; differences are handled at render time.

### 5. Minimal Re-exports

Only output types (`QueryResult`), interfaces (`FilterItem`), and enums are re-exported. Input types stay internal.

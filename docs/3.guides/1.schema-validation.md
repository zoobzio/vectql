---
title: Schema Validation
description: VDML integration and validation patterns
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Guide
  - Schema
  - VDML
  - Validation
---

# Schema Validation

VECTQL validates queries against a VDML schema. This guide covers schema setup, validation behavior, and error handling.

## Defining a Schema

Create a VDML schema with collections, embeddings, and metadata:

```go
import "github.com/zoobzio/vdml"

schema := vdml.NewSchema("myapp")

// Products collection
products := vdml.NewCollection("products")
products.AddEmbedding(
    vdml.NewEmbedding("embedding", 1536).
        WithMetric(vdml.Cosine),
)
products.AddMetadata(vdml.NewMetadataField("name", vdml.TypeString))
products.AddMetadata(vdml.NewMetadataField("category", vdml.TypeString))
products.AddMetadata(vdml.NewMetadataField("price", vdml.TypeFloat))
products.AddMetadata(vdml.NewMetadataField("tags", vdml.TypeStringArray))
schema.AddCollection(products)

// Documents collection
documents := vdml.NewCollection("documents")
documents.AddEmbedding(
    vdml.NewEmbedding("content", 768).
        WithMetric(vdml.DotProduct),
)
documents.AddMetadata(vdml.NewMetadataField("title", vdml.TypeString))
documents.AddMetadata(vdml.NewMetadataField("source", vdml.TypeString))
documents.AddMetadata(vdml.NewMetadataField("page", vdml.TypeInt))
schema.AddCollection(documents)
```

## Creating an Instance

Bind the schema to a VECTQL instance:

```go
instance, err := vectql.NewFromVDML(schema)
if err != nil {
    return err
}
```

The instance caches collection, embedding, and metadata lookups for fast validation.

## Validation Behavior

### Collection Validation

Collections must exist in the schema:

```go
instance.C("products")       // Valid: collection exists
instance.C("nonexistent")    // Panics: collection not found
```

### Embedding Validation

Embeddings must exist in the specified collection:

```go
instance.E("products", "embedding")   // Valid
instance.E("products", "unknown")     // Panics: embedding not found
instance.E("documents", "embedding")  // Panics: wrong collection
```

### Metadata Validation

Metadata fields must exist in the specified collection:

```go
instance.M("products", "category")    // Valid
instance.M("products", "title")       // Panics: title not in products
instance.M("documents", "title")      // Valid: exists in documents
```

### Parameter Validation

Parameters must be valid identifiers:

```go
instance.P("query_vec")        // Valid
instance.P("category123")      // Valid
instance.P("invalid-name")     // Panics: contains hyphen
instance.P("1starts")          // Panics: starts with number
```

## Panic vs Error

By default, validation failures panic for early error detection:

```go
// These panic on invalid input
collection := instance.C("products")
embedding := instance.E("products", "embedding")
metadata := instance.M("products", "category")
param := instance.P("value")
```

### Try Variants

For runtime validation with user input, use `Try` variants:

```go
collection, err := instance.TryC(collectionName)
if err != nil {
    return fmt.Errorf("invalid collection: %w", err)
}

embedding, err := instance.TryE(collectionName, embeddingName)
if err != nil {
    return fmt.Errorf("invalid embedding: %w", err)
}

metadata, err := instance.TryM(collectionName, fieldName)
if err != nil {
    return fmt.Errorf("invalid metadata field: %w", err)
}

param, err := instance.TryP(paramName)
if err != nil {
    return fmt.Errorf("invalid param: %w", err)
}
```

### When to Use Each

| Scenario | Use |
|----------|-----|
| Static field names in code | `instance.E("products", "embedding")` |
| User-provided field names | `instance.TryM(collection, userInput)` |
| Configuration-driven queries | `instance.TryC(config.CollectionName)` |
| Tests | Either works |

## Multiple Embeddings

Collections can have multiple embeddings for different use cases:

```go
products := vdml.NewCollection("products").
    AddEmbedding(vdml.NewEmbedding("text_embedding", 1536).WithMetric(vdml.Cosine)).
    AddEmbedding(vdml.NewEmbedding("image_embedding", 512).WithMetric(vdml.Euclidean))

// Use different embeddings for different searches
textSearch := vectql.Search(v.C("products")).
    Vector(vectql.Vec(v.P("text_vec"))).
    Embedding(v.E("products", "text_embedding"))

imageSearch := vectql.Search(v.C("products")).
    Vector(vectql.Vec(v.P("image_vec"))).
    Embedding(v.E("products", "image_embedding"))
```

## Schema Organization

### Single Schema Instance

Create one instance per schema and reuse it:

```go
var db *vectql.VECTQL

func init() {
    schema := buildSchema()
    instance, err := vectql.NewFromVDML(schema)
    if err != nil {
        panic(err)
    }
    db = instance
}

func SearchProducts(queryVec []float32) (*vectql.QueryResult, error) {
    return vectql.Search(db.C("products")).
        Vector(vectql.Vec(db.P("query_vec"))).
        Embedding(db.E("products", "embedding")).
        TopK(10).
        Render(pinecone.New())
}
```

### Multiple Schemas

For microservices with different vector stores:

```go
var (
    productsDB  *vectql.VECTQL  // Product search
    documentsDB *vectql.VECTQL  // RAG documents
    imagesDB    *vectql.VECTQL  // Image search
)
```

## Validation Errors

### Error Types

| Error | Cause |
|-------|-------|
| `collection 'X' not found in schema` | Collection doesn't exist |
| `embedding 'X' not found in collection 'Y'` | Embedding doesn't exist |
| `metadata field 'X' not found in collection 'Y'` | Metadata doesn't exist |
| `invalid parameter name: X` | Parameter contains invalid characters |

### Handling Errors

```go
result, err := query.Render(pinecone.New())
if err != nil {
    switch {
    case strings.Contains(err.Error(), "not found in schema"):
        log.Error("schema validation failed", "error", err)
    case strings.Contains(err.Error(), "invalid"):
        return nil, fmt.Errorf("invalid query: %w", err)
    default:
        return nil, err
    }
}
```

## Metadata Types

VDML supports various metadata types:

| VDML Type | Go Type | Description |
|-----------|---------|-------------|
| `TypeString` | string | Text values |
| `TypeInt` | int64 | Integer values |
| `TypeFloat` | float64 | Floating point |
| `TypeBool` | bool | Boolean values |
| `TypeStringArray` | []string | String arrays |
| `TypeIntArray` | []int64 | Integer arrays |

Types are used for documentation and potential future type checking.

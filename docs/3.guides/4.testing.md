---
title: Testing
description: Testing patterns for VECTQL queries
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Guide
  - Testing
  - Best Practices
---

# Testing

This guide covers testing strategies for VECTQL queries.

## Test Helpers

VECTQL provides test utilities in the `testing` package:

```go
import vectqltesting "github.com/zoobzio/vectql/testing"

func TestQuery(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    result, err := vectql.Search(instance.C("products")).
        Vector(vectql.Vec(instance.P("query_vec"))).
        Embedding(instance.E("products", "embedding")).
        TopK(10).
        Render(pinecone.New())

    vectqltesting.AssertNoError(t, err)
    vectqltesting.AssertContainsParam(t, result.RequiredParams, "query_vec")
}
```

### Available Helpers

| Function | Description |
|----------|-------------|
| `TestInstance(t)` | Creates a VECTQL instance with test schema |
| `AssertNoError(t, err)` | Fails if error is not nil |
| `AssertError(t, err)` | Fails if error is nil |
| `AssertParams(t, expected, actual)` | Checks required params match |
| `AssertContainsParam(t, params, param)` | Checks param is required |
| `AssertPanics(t, fn)` | Checks that function panics |
| `AssertJSON(t, expected, actual)` | Compares JSON output |

## Unit Testing

### Testing Query Structure

Test that queries produce the expected structure:

```go
func TestSearchWithFilter(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    result, err := vectql.Search(instance.C("products")).
        Vector(vectql.Vec(instance.P("query_vec"))).
        Embedding(instance.E("products", "embedding")).
        TopK(10).
        Filter(instance.Eq(instance.M("products", "category"), instance.P("category"))).
        Render(pinecone.New())

    vectqltesting.AssertNoError(t, err)

    // Check parameters
    vectqltesting.AssertParams(t, []string{"query_vec", "category"}, result.RequiredParams)

    // Check JSON contains expected fields
    if !strings.Contains(result.JSON, `"topK":10`) {
        t.Error("Expected topK in output")
    }
    if !strings.Contains(result.JSON, `"filter"`) {
        t.Error("Expected filter in output")
    }
}
```

### Testing Validation

Test that invalid inputs are rejected:

```go
func TestInvalidCollection(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    vectqltesting.AssertPanics(t, func() {
        instance.C("nonexistent")
    })
}

func TestInvalidEmbedding(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    vectqltesting.AssertPanics(t, func() {
        instance.E("products", "nonexistent")
    })
}

func TestInvalidMetadata(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    vectqltesting.AssertPanics(t, func() {
        instance.M("products", "nonexistent")
    })
}
```

### Testing Try Variants

```go
func TestTryC_InvalidCollection(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    _, err := instance.TryC("nonexistent")
    vectqltesting.AssertError(t, err)
}

func TestTryE_InvalidEmbedding(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    _, err := instance.TryE("products", "nonexistent")
    vectqltesting.AssertError(t, err)
}
```

### Testing Filters

```go
func TestAndFilter(t *testing.T) {
    instance := vectqltesting.TestInstance(t)

    filter := instance.And(
        instance.Eq(instance.M("products", "active"), instance.P("active")),
        instance.Gt(instance.M("products", "price"), instance.P("min_price")),
    )

    result, err := vectql.Search(instance.C("products")).
        Vector(vectql.Vec(instance.P("query_vec"))).
        Embedding(instance.E("products", "embedding")).
        TopK(10).
        Filter(filter).
        Render(pinecone.New())

    vectqltesting.AssertNoError(t, err)
    vectqltesting.AssertParams(t, []string{"query_vec", "active", "min_price"}, result.RequiredParams)
}
```

## Table-Driven Tests

Use table-driven tests for comprehensive coverage:

```go
func TestFilterOperators(t *testing.T) {
    instance := vectqltesting.TestInstance(t)
    field := instance.M("products", "price")
    param := instance.P("value")

    tests := []struct {
        name     string
        filter   vectql.FilterItem
        expected string
    }{
        {"Eq", instance.Eq(field, param), `"$eq"`},
        {"Ne", instance.Ne(field, param), `"$ne"`},
        {"Gt", instance.Gt(field, param), `"$gt"`},
        {"Gte", instance.Gte(field, param), `"$gte"`},
        {"Lt", instance.Lt(field, param), `"$lt"`},
        {"Lte", instance.Lte(field, param), `"$lte"`},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := vectql.Search(instance.C("products")).
                Vector(vectql.Vec(instance.P("vec"))).
                Embedding(instance.E("products", "embedding")).
                TopK(10).
                Filter(tt.filter).
                Render(pinecone.New())

            vectqltesting.AssertNoError(t, err)

            if !strings.Contains(result.JSON, tt.expected) {
                t.Errorf("Expected %s in output, got: %s", tt.expected, result.JSON)
            }
        })
    }
}
```

## Integration Testing

For integration tests with real vector databases, use testcontainers:

```go
func TestQdrant_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    ctx := context.Background()

    // Start Qdrant container
    container, err := qdrant.Run(ctx, "qdrant/qdrant:latest")
    if err != nil {
        t.Fatal(err)
    }
    defer container.Terminate(ctx)

    // Get endpoint
    endpoint, _ := container.RESTEndpoint(ctx)

    // Build and test query
    instance := createTestInstance(t)
    result, err := vectql.Search(instance.C("products")).
        Vector(vectql.Vec(instance.P("query_vec"))).
        Embedding(instance.E("products", "embedding")).
        TopK(10).
        Render(qdrant.New())

    if err != nil {
        t.Fatal(err)
    }

    // Verify result structure
    if result.JSON == "" {
        t.Error("Expected non-empty JSON")
    }
}
```

## Benchmarking

Benchmark query building and rendering:

```go
func BenchmarkSimpleSearch(b *testing.B) {
    instance := createBenchmarkInstance(b)
    collection := instance.C("products")
    embedding := instance.E("products", "embedding")
    vec := vectql.Vec(instance.P("query_vec"))

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, err := vectql.Search(collection).
            Vector(vec).
            Embedding(embedding).
            TopK(10).
            Render(pinecone.New())
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkSearchWithFilter(b *testing.B) {
    instance := createBenchmarkInstance(b)

    b.ResetTimer()
    b.ReportAllocs()

    for i := 0; i < b.N; i++ {
        _, err := vectql.Search(instance.C("products")).
            Vector(vectql.Vec(instance.P("query_vec"))).
            Embedding(instance.E("products", "embedding")).
            TopK(10).
            Filter(instance.And(
                instance.Eq(instance.M("products", "active"), instance.P("active")),
                instance.Gt(instance.M("products", "price"), instance.P("min_price")),
            )).
            Render(pinecone.New())

        if err != nil {
            b.Fatal(err)
        }
    }
}
```

Run benchmarks:

```bash
go test -bench=. -benchmem ./...
```

## Test Organization

Recommended test file structure:

```
vectql/
├── builder_test.go          # Builder unit tests
├── expressions_test.go      # Filter expression tests
├── instance_test.go         # Instance/validation tests
├── testing/
│   ├── helpers.go           # Test utilities
│   ├── helpers_test.go      # Utility tests
│   ├── benchmarks/
│   │   └── render_benchmark_test.go
│   └── integration/
│       ├── setup_test.go
│       └── qdrant_test.go
└── pkg/
    ├── pinecone/
    │   └── pinecone_test.go
    └── ...
```

## Best Practices

1. **Test all providers** - Verify output for each supported provider
2. **Test error cases** - Ensure invalid inputs are rejected
3. **Use table-driven tests** - Cover all filter operators systematically
4. **Benchmark critical paths** - Track performance of common queries
5. **Integration test sparingly** - Unit tests are faster and more reliable

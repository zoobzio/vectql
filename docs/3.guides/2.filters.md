---
title: Filters
description: Building metadata filters for vector search
author: zoobzio
published: 2025-12-30
updated: 2025-12-30
tags:
  - Guide
  - Filters
  - Metadata
---

# Filters

Filters constrain vector search results by metadata. VECTQL provides a rich set of filter operators that translate to provider-specific syntax.

## Basic Comparison

### Equality

```go
filter := v.Eq(v.M("products", "category"), v.P("category"))
// Pinecone: {"category": {"$eq": ":category"}}
// Qdrant: {"must": [{"key": "category", "match": {"value": ":category"}}]}
```

### Inequality

```go
filter := v.Ne(v.M("products", "status"), v.P("status"))
// Pinecone: {"status": {"$ne": ":status"}}
```

### Comparison Operators

```go
// Greater than
v.Gt(v.M("products", "price"), v.P("min_price"))

// Greater than or equal
v.Gte(v.M("products", "price"), v.P("min_price"))

// Less than
v.Lt(v.M("products", "price"), v.P("max_price"))

// Less than or equal
v.Lte(v.M("products", "price"), v.P("max_price"))
```

## Set Membership

### In

Check if a field value is in a set:

```go
filter := v.In(v.M("products", "category"), v.P("categories"))
// Pinecone: {"category": {"$in": ":categories"}}
```

### Not In

Check if a field value is not in a set:

```go
filter := v.NotIn(v.M("products", "status"), v.P("excluded"))
// Pinecone: {"status": {"$nin": ":excluded"}}
```

## Existence

### Field Exists

```go
filter := vectql.Exists(v.M("products", "discount"))
// Pinecone: {"discount": {"$exists": true}}
```

### Field Not Exists

```go
filter := vectql.NotExists(v.M("products", "deleted_at"))
// Pinecone: {"deleted_at": {"$exists": false}}
```

## Logical Operators

### AND

All conditions must be true:

```go
filter := v.And(
    v.Eq(v.M("products", "active"), v.P("active")),
    v.Gt(v.M("products", "price"), v.P("min_price")),
)
// Pinecone: {"$and": [{"active": ":active"}, {"price": {"$gt": ":min_price"}}]}
// Qdrant: {"must": [...]}
```

### OR

At least one condition must be true:

```go
filter := v.Or(
    v.Eq(v.M("products", "category"), v.P("cat1")),
    v.Eq(v.M("products", "category"), v.P("cat2")),
)
// Pinecone: {"$or": [{"category": ":cat1"}, {"category": ":cat2"}]}
// Qdrant: {"should": [...]}
```

### NOT

Negate a condition:

```go
filter := v.Not(
    v.Eq(v.M("products", "status"), v.P("excluded")),
)
// Pinecone: {"status": {"$ne": ":excluded"}}
// Qdrant: {"must_not": [...]}
```

## Nested Conditions

Combine logical operators for complex queries:

```go
// Active products that are either on sale OR premium
filter := v.And(
    v.Eq(v.M("products", "active"), v.P("active")),
    v.Or(
        v.Eq(v.M("products", "on_sale"), v.P("on_sale")),
        v.Eq(v.M("products", "tier"), v.P("premium")),
    ),
)
```

## Range Queries

### Inclusive Range

```go
minPrice := v.P("min_price")
maxPrice := v.P("max_price")
filter := vectql.Range(v.M("products", "price"), &minPrice, &maxPrice)
// Pinecone: {"price": {"$gte": ":min_price", "$lte": ":max_price"}}
```

### Exclusive Range

```go
filter := vectql.RangeExclusive(v.M("products", "price"), &minPrice, &maxPrice)
// Pinecone: {"price": {"$gt": ":min_price", "$lt": ":max_price"}}
```

### One-Sided Range

```go
// Only minimum
filter := vectql.Range(v.M("products", "price"), &minPrice, nil)
// Pinecone: {"price": {"$gte": ":min_price"}}

// Only maximum
filter := vectql.Range(v.M("products", "price"), nil, &maxPrice)
// Pinecone: {"price": {"$lte": ":max_price"}}
```

## String Operations

### Contains

```go
filter := v.Contains(v.M("products", "name"), v.P("search_term"))
```

### Starts With

```go
filter := v.StartsWith(v.M("products", "sku"), v.P("prefix"))
```

### Ends With

```go
filter := v.EndsWith(v.M("products", "filename"), v.P("extension"))
```

## Array Operations

### Array Contains

Check if an array field contains a value:

```go
filter := v.ArrayContains(v.M("products", "tags"), v.P("tag"))
// Matches documents where tags array includes the specified tag
```

### Array Contains Any

Check if array contains any of the values:

```go
filter := v.ArrayContainsAny(v.M("products", "tags"), v.P("tags"))
```

### Array Contains All

Check if array contains all values:

```go
filter := v.ArrayContainsAll(v.M("products", "tags"), v.P("required_tags"))
```

## Provider Support

Not all providers support all filters:

| Filter | Pinecone | Qdrant | Milvus | Weaviate |
|--------|----------|--------|--------|----------|
| Eq, Ne | Yes | Yes | Yes | Yes |
| Gt, Gte, Lt, Lte | Yes | Yes | Yes | Yes |
| In, NotIn | Yes | Yes | Yes | Yes |
| Exists | Yes | Yes | Yes | Yes |
| And | Yes | Yes | Yes | Yes |
| Or | Yes | Yes | Yes | Yes |
| Not | Yes | Yes | Yes | Yes |
| Range | Yes | Yes | Yes | Yes |
| Contains | Limited | Yes | Yes | Yes |
| ArrayContains | Yes | Yes | Yes | Yes |

Unsupported filters return an error at render time.

## Filter Patterns

### Optional Filters

Build filters conditionally:

```go
func buildFilter(v *vectql.VECTQL, opts SearchOptions) vectql.FilterItem {
    var conditions []vectql.FilterItem

    if opts.Category != "" {
        conditions = append(conditions,
            v.Eq(v.M("products", "category"), v.P("category")))
    }

    if opts.MinPrice > 0 {
        conditions = append(conditions,
            v.Gte(v.M("products", "price"), v.P("min_price")))
    }

    if opts.Active {
        conditions = append(conditions,
            v.Eq(v.M("products", "active"), v.P("active")))
    }

    if len(conditions) == 0 {
        return nil
    }
    if len(conditions) == 1 {
        return conditions[0]
    }
    return v.And(conditions...)
}
```

### Reusable Filter Components

```go
func activeFilter(v *vectql.VECTQL) vectql.FilterItem {
    return v.Eq(v.M("products", "active"), v.P("active"))
}

func categoryFilter(v *vectql.VECTQL) vectql.FilterItem {
    return v.Eq(v.M("products", "category"), v.P("category"))
}

// Combine
filter := v.And(
    activeFilter(v),
    categoryFilter(v),
)
```
